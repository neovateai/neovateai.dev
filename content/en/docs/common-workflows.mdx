# Common Workflows

> Learn about common workflows with Neovate Code.

Each task in this document includes clear instructions, example commands, and best practices to help you get the most from Neovate Code.

## Understand new codebases

### Get a quick codebase overview

Suppose you've just joined a new project and need to understand its structure quickly.

1. Navigate to the project root directory

```bash
cd /path/to/project
```

2. Start Neovate Code

```bash
neovate
```

3. Ask for a high-level overview

```
> give me an overview of this codebase
```

4. Dive deeper into specific components

```
> explain the main architecture patterns used here
> what are the key data models?
> how is authentication handled?
```

> **Tips:**
> - Start with broad questions, then narrow down to specific areas
> - Ask about coding conventions and patterns used in the project
> - Request a glossary of project-specific terms

### Find relevant code

Suppose you need to locate code related to a specific feature or functionality.

1. Ask Neovate to find relevant files

```
> find the files that handle user authentication
```

2. Get context on how components interact

```
> how do these authentication files work together?
```

3. Understand the execution flow

```
> trace the login process from front-end to database
```

> **Tips:**
> - Be specific about what you're looking for
> - Use domain language from the project

---

## Fix bugs efficiently

Suppose you've encountered an error message and need to find and fix its source.

1. Share the error with Neovate

```
> I'm seeing an error when I run npm test
```

2. Ask for fix recommendations

```
> suggest a few ways to fix the @ts-ignore in user.ts
```

3. Apply the fix

```
> update user.ts to add the null check you suggested
```

> **Tips:**
> - Tell Neovate the command to reproduce the issue and get a stack trace
> - Mention any steps to reproduce the error
> - Let Neovate know if the error is intermittent or consistent

---

## Refactor code

Suppose you need to update old code to use modern patterns and practices.

1. Identify legacy code for refactoring

```
> find deprecated API usage in our codebase
```

2. Get refactoring recommendations

```
> suggest how to refactor utils.js to use modern JavaScript features
```

3. Apply the changes safely

```
> refactor utils.js to use ES2024 features while maintaining the same behavior
```

4. Verify the refactoring

```
> run tests for the refactored code
```

> **Tips:**
> - Ask Neovate to explain the benefits of the modern approach
> - Request that changes maintain backward compatibility when needed
> - Do refactoring in small, testable increments

---

## Use Plan Mode for safe code analysis

Plan Mode instructs Neovate to create a plan by analyzing the codebase with read-only operations, perfect for exploring codebases, planning complex changes, or reviewing code safely.

### When to use Plan Mode

- **Multi-step implementation**: When your feature requires making edits to many files
- **Code exploration**: When you want to research the codebase thoroughly before changing anything
- **Interactive development**: When you want to iterate on the direction with Neovate

### How to use Plan Mode

**Turn on Plan Mode during a session**

You can switch into Plan Mode during a session using **Shift+Tab** to cycle through different modes.

---

## Work with tests

Suppose you need to add tests for uncovered code.

1. Identify untested code

```
> find functions in NotificationsService.swift that are not covered by tests
```

2. Generate test scaffolding

```
> add tests for the notification service
```

3. Add meaningful test cases

```
> add test cases for edge conditions in the notification service
```

4. Run and verify tests

```
> run the new tests and fix any failures
```

Neovate can generate tests that follow your project's existing patterns and conventions. When asking for tests, be specific about what behavior you want to verify. Neovate examines your existing test files to match the style, frameworks, and assertion patterns already in use.

For comprehensive coverage, ask Neovate to identify edge cases you might have missed. Neovate can analyze your code paths and suggest tests for error conditions, boundary values, and unexpected inputs that are easy to overlook.

---

## Create pull requests

Suppose you need to create a well-documented pull request for your changes.

1. Summarize your changes

```
> summarize the changes I've made to the authentication module
```

2. Generate a pull request with Neovate

```
> create a pr
```

3. Review and refine

```
> enhance the PR description with more context about the security improvements
```

4. Add testing details

```
> add information about how these changes were tested
```

> **Tips:**
> - Ask Neovate directly to make a PR for you
> - Review Neovate's generated PR before submitting
> - Ask Neovate to highlight potential risks or considerations

---

## Handle documentation

Suppose you need to add or update documentation for your code.

1. Identify undocumented code

```
> find functions without proper JSDoc comments in the auth module
```

2. Generate documentation

```
> add JSDoc comments to the undocumented functions in auth.js
```

3. Review and enhance

```
> improve the generated documentation with more context and examples
```

4. Verify documentation

```
> check if the documentation follows our project standards
```

> **Tips:**
> - Specify the documentation style you want (JSDoc, docstrings, etc.)
> - Ask for examples in the documentation
> - Request documentation for public APIs, interfaces, and complex logic

---

## Work with images

Suppose you need to work with images in your codebase, and you want Neovate's help analyzing image content.

1. Add an image to the conversation

You can use any of these methods:
- Drag and drop an image into the Neovate Code window
- Copy an image and paste it into the CLI with ctrl+v
- Provide an image path: "Analyze this image: /path/to/your/image.png"

2. Ask Neovate to analyze the image

```
> What does this image show?
> Describe the UI elements in this screenshot
> Are there any problematic elements in this diagram?
```

3. Use images for context

```
> Here's a screenshot of the error. What's causing it?
> This is our current database schema. How should we modify it for the new feature?
```

4. Get code suggestions from visual content

```
> Generate CSS to match this design mockup
> What HTML structure would recreate this component?
```

> **Tips:**
> - Use images when text descriptions would be unclear or cumbersome
> - Include screenshots of errors, UI designs, or diagrams for better context
> - You can work with multiple images in a conversation
> - Image analysis works with diagrams, screenshots, mockups, and more

---

## Reference files and directories

Use @ to quickly include files or directories without waiting for Neovate to read them.

1. Reference a single file

```
> Explain the logic in @src/utils/auth.js
```

This includes the full content of the file in the conversation.

2. Reference a directory

```
> What's the structure of @src/components?
```

This provides a directory listing with file information.

3. Reference MCP resources

```
> Show me the data from @github:repos/owner/repo/issues
```

This fetches data from connected MCP servers using the format @server:resource. See [MCP documentation](/docs/mcp) for details.

> **Tips:**
> - File paths can be relative or absolute
> - @ file references add `AGENTS.md` in the file's directory and parent directories to context
> - Directory references show file listings, not contents
> - You can reference multiple files in a single message (e.g., "@file1.js and @file2.js")

---

## Resume previous conversations

When starting Neovate Code, you can resume a previous session:

- `neovate --continue` continues the most recent conversation in the current directory
- `neovate --resume` opens a conversation picker or resumes by name

From inside an active session, use `/resume` to switch to a different conversation.

Sessions are stored per project directory. The `/resume` picker shows sessions from the same git repository, including worktrees.

### Name your sessions

Give sessions descriptive names to find them later. This is a best practice when working on multiple tasks or features.

1. Name the current session

Use `/rename` during a session to give it a memorable name:

```
> /rename auth-refactor
```

You can also rename any session from the picker: run `/resume`, navigate to a session, and press `R`.

2. Resume by name later

From the command line:

```bash
neovate --resume auth-refactor
```

Or from inside an active session:

```
> /resume auth-refactor
```

### Use the session picker

The `/resume` command (or `neovate --resume` without arguments) opens an interactive session picker with these features:

| Shortcut | Action |
| :--- | :--- |
| `↑` / `↓` | Navigate between sessions |
| `→` / `←` | Expand or collapse grouped sessions |
| `Enter` | Select and resume the highlighted session |
| `P` | Preview the session content |
| `R` | Rename the highlighted session |
| `/` | Search to filter sessions |
| `A` | Toggle between current directory and all projects |
| `B` | Filter to sessions from your current git branch |
| `Esc` | Exit the picker or search mode |

> **Tips:**
> - **Name sessions early**: Use `/rename` when starting work on a distinct task—it's much easier to find "payment-integration" than "explain this function" later
> - Use `--continue` for quick access to your most recent conversation
> - Use `--resume session-name` when you know which session you need
> - Use `--resume` (without a name) when you need to browse and select
> - For scripts, use `neovate --continue --print "prompt"` to resume in non-interactive mode
> - Press `P` in the picker to preview a session before resuming it

---

## Create custom slash commands

Neovate Code supports custom slash commands that you can create to quickly execute specific prompts or tasks.

For more details, see the [Slash commands](/docs/slash-commands) reference page.

### Create project-specific commands

Suppose you want to create reusable slash commands for your project that all team members can use.

1. Create a commands directory in your project

```bash
mkdir -p .neovate/commands
```

2. Create a Markdown file for each command

```bash
echo "Analyze the performance of this code and suggest three specific optimizations:" > .neovate/commands/optimize.md
```

3. Use your custom command in Neovate Code

```
> /optimize
```

> **Tips:**
> - Command names are derived from the filename (e.g., `optimize.md` becomes `/optimize`)
> - You can organize commands in subdirectories (e.g., `.neovate/commands/frontend/component.md` creates `/component` with "(project:frontend)" shown in the description)
> - Project commands are available to everyone who clones the repository
> - The Markdown file content becomes the prompt sent to Neovate when the command is invoked

### Add command arguments with $ARGUMENTS

Suppose you want to create flexible slash commands that can accept additional input from users.

1. Create a command file with the $ARGUMENTS placeholder

```bash
echo 'Find and fix issue #$ARGUMENTS. Follow these steps:
1. Understand the issue described in the ticket
2. Locate the relevant code in our codebase
3. Implement a solution that addresses the root cause
4. Add appropriate tests
5. Prepare a concise PR description' > .neovate/commands/fix-issue.md
```

2. Use the command with an issue number

```
> /fix-issue 123
```

This replaces $ARGUMENTS with "123" in the prompt.

> **Tips:**
> - The $ARGUMENTS placeholder is replaced with any text that follows the command
> - You can position $ARGUMENTS anywhere in your command template
> - Other useful applications: generating test cases for specific functions, creating documentation for components, reviewing code in particular files, or translating content to specified languages

### Create personal slash commands

Suppose you want to create personal slash commands that work across all your projects.

1. Create a commands directory in your home folder

```bash
mkdir -p ~/.neovate/commands
```

2. Create a Markdown file for each command

```bash
echo "Review this code for security vulnerabilities, focusing on:" > ~/.neovate/commands/security-review.md
```

3. Use your personal custom command

```
> /security-review
```

> **Tips:**
> - Personal commands show "(user)" in their description when listed with `/help`
> - Personal commands are only available to you and not shared with your team
> - Personal commands work across all your projects
> - You can use these for consistent workflows across different codebases

---

## What's next?

- [CLI Reference](/docs/cli) - All commands and options
- [Settings](/docs/settings) - Customize Neovate for your workflow
- [Slash Commands](/docs/slash-commands) - Create reusable prompt templates
- [Subagents](/docs/subagents) - Spawn child agents for parallel tasks
