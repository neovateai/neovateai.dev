# 常用工作流

> 了解 Neovate Code 的常用工作流程。

本文档中的每个任务都包含清晰的说明、示例命令和最佳实践，帮助您充分利用 Neovate Code。

## 理解新代码库

### 快速了解代码库概览

假设您刚加入一个新项目，需要快速了解其结构。

1. 导航到项目根目录

```bash
cd /path/to/project
```

2. 启动 Neovate Code

```bash
neovate
```

3. 询问高层次概览

```
> 给我一个这个代码库的概览
```

4. 深入了解具体组件

```
> 解释这里使用的主要架构模式
> 关键的数据模型是什么？
> 认证是如何处理的？
```

> **提示：**
> - 从宽泛的问题开始，然后逐步缩小到具体领域
> - 询问项目中使用的编码规范和模式
> - 请求项目特定术语的词汇表

### 查找相关代码

假设您需要找到与特定功能相关的代码。

1. 让 Neovate 查找相关文件

```
> 找到处理用户认证的文件
```

2. 了解组件如何交互

```
> 这些认证文件是如何协同工作的？
```

3. 理解执行流程

```
> 追踪从前端到数据库的登录过程
```

> **提示：**
> - 具体说明您要找什么
> - 使用项目中的领域语言

---

## 高效修复 Bug

假设您遇到了错误消息，需要找到并修复其来源。

1. 与 Neovate 分享错误

```
> 我在运行 npm test 时看到一个错误
```

2. 询问修复建议

```
> 建议几种修复 user.ts 中 @ts-ignore 的方法
```

3. 应用修复

```
> 更新 user.ts 添加你建议的空值检查
```

> **提示：**
> - 告诉 Neovate 重现问题的命令并获取堆栈跟踪
> - 提及重现错误的步骤
> - 让 Neovate 知道错误是间歇性的还是持续的

---

## 重构代码

假设您需要更新旧代码以使用现代模式和实践。

1. 识别需要重构的遗留代码

```
> 在我们的代码库中查找已弃用的 API 用法
```

2. 获取重构建议

```
> 建议如何重构 utils.js 以使用现代 JavaScript 特性
```

3. 安全地应用更改

```
> 重构 utils.js 使用 ES2024 特性，同时保持相同的行为
```

4. 验证重构

```
> 运行重构代码的测试
```

> **提示：**
> - 让 Neovate 解释现代方法的好处
> - 要求在需要时保持向后兼容性
> - 以小的、可测试的增量进行重构

---

## 使用计划模式进行安全的代码分析

计划模式指示 Neovate 通过只读操作分析代码库来创建计划，非常适合探索代码库、规划复杂更改或安全地审查代码。

### 何时使用计划模式

- **多步骤实现**：当您的功能需要编辑多个文件时
- **代码探索**：当您想在更改任何内容之前彻底研究代码库时
- **交互式开发**：当您想与 Neovate 迭代方向时

### 如何使用计划模式

**在会话期间打开计划模式**

您可以在会话期间使用 **Shift+Tab** 循环切换不同模式。

---

## 处理测试

假设您需要为未覆盖的代码添加测试。

1. 识别未测试的代码

```
> 查找 NotificationsService.swift 中没有被测试覆盖的函数
```

2. 生成测试脚手架

```
> 为通知服务添加测试
```

3. 添加有意义的测试用例

```
> 为通知服务的边界条件添加测试用例
```

4. 运行并验证测试

```
> 运行新测试并修复任何失败
```

Neovate 可以生成遵循您项目现有模式和规范的测试。在请求测试时，请具体说明您想要验证的行为。Neovate 会检查您现有的测试文件以匹配已在使用的风格、框架和断言模式。

为了获得全面的覆盖，请让 Neovate 识别您可能遗漏的边界情况。Neovate 可以分析您的代码路径，并建议针对错误条件、边界值和容易忽略的意外输入的测试。

---

## 创建拉取请求

假设您需要为您的更改创建一个文档完善的拉取请求。

1. 总结您的更改

```
> 总结我对认证模块所做的更改
```

2. 使用 Neovate 生成拉取请求

```
> 创建一个 pr
```

3. 审查并完善

```
> 用更多关于安全改进的上下文增强 PR 描述
```

4. 添加测试详情

```
> 添加关于如何测试这些更改的信息
```

> **提示：**
> - 直接让 Neovate 为您创建 PR
> - 在提交前审查 Neovate 生成的 PR
> - 让 Neovate 突出显示潜在的风险或注意事项

---

## 处理文档

假设您需要为代码添加或更新文档。

1. 识别未文档化的代码

```
> 在 auth 模块中查找没有适当 JSDoc 注释的函数
```

2. 生成文档

```
> 为 auth.js 中未文档化的函数添加 JSDoc 注释
```

3. 审查并增强

```
> 用更多上下文和示例改进生成的文档
```

4. 验证文档

```
> 检查文档是否遵循我们的项目标准
```

> **提示：**
> - 指定您想要的文档风格（JSDoc、docstrings 等）
> - 请求在文档中添加示例
> - 请求为公共 API、接口和复杂逻辑编写文档

---

## 处理图片

假设您需要在代码库中处理图片，并希望 Neovate 帮助分析图片内容。

1. 将图片添加到对话中

您可以使用以下任何方法：
- 将图片拖放到 Neovate Code 窗口中
- 复制图片并使用 ctrl+v 粘贴到 CLI 中
- 提供图片路径："分析这张图片：/path/to/your/image.png"

2. 让 Neovate 分析图片

```
> 这张图片显示了什么？
> 描述这个截图中的 UI 元素
> 这个图表中有任何问题元素吗？
```

3. 使用图片作为上下文

```
> 这是错误的截图。是什么导致的？
> 这是我们当前的数据库架构。我们应该如何为新功能修改它？
```

4. 从视觉内容获取代码建议

```
> 生成与此设计稿匹配的 CSS
> 什么样的 HTML 结构可以重建这个组件？
```

> **提示：**
> - 当文字描述不清晰或繁琐时使用图片
> - 包含错误截图、UI 设计或图表以获得更好的上下文
> - 您可以在对话中使用多张图片
> - 图片分析适用于图表、截图、设计稿等

---

## 引用文件和目录

使用 @ 快速包含文件或目录，无需等待 Neovate 读取它们。

1. 引用单个文件

```
> 解释 @src/utils/auth.js 中的逻辑
```

这会将文件的完整内容包含在对话中。

2. 引用目录

```
> @src/components 的结构是什么？
```

这会提供带有文件信息的目录列表。

3. 引用 MCP 资源

```
> 显示 @github:repos/owner/repo/issues 的数据
```

这会使用 @server:resource 格式从连接的 MCP 服务器获取数据。有关详情，请参阅 [MCP 文档](/docs/mcp)。

> **提示：**
> - 文件路径可以是相对路径或绝对路径
> - @ 文件引用会将文件目录及其父目录中的 `AGENTS.md` 添加到上下文
> - 目录引用显示文件列表，而不是内容
> - 您可以在单条消息中引用多个文件（例如，"@file1.js 和 @file2.js"）

---

## 恢复之前的对话

启动 Neovate Code 时，您可以恢复之前的会话：

- `neovate --continue` 继续当前目录中最近的对话
- `neovate --resume` 打开对话选择器或按名称恢复

在活动会话中，使用 `/resume` 切换到不同的对话。

会话按项目目录存储。`/resume` 选择器显示来自同一 git 仓库的会话，包括工作树。

### 命名您的会话

给会话起描述性的名称以便以后找到。这是处理多个任务或功能时的最佳实践。

1. 命名当前会话

在会话期间使用 `/rename` 给它一个易记的名称：

```
> /rename auth-refactor
```

您也可以从选择器中重命名任何会话：运行 `/resume`，导航到一个会话，然后按 `R`。

2. 稍后按名称恢复

从命令行：

```bash
neovate --resume auth-refactor
```

或从活动会话内：

```
> /resume auth-refactor
```

### 使用会话选择器

`/resume` 命令（或不带参数的 `neovate --resume`）打开一个具有以下功能的交互式会话选择器：

| 快捷键 | 操作 |
| :--- | :--- |
| `↑` / `↓` | 在会话之间导航 |
| `→` / `←` | 展开或折叠分组的会话 |
| `Enter` | 选择并恢复突出显示的会话 |
| `P` | 预览会话内容 |
| `R` | 重命名突出显示的会话 |
| `/` | 搜索以过滤会话 |
| `A` | 在当前目录和所有项目之间切换 |
| `B` | 过滤到当前 git 分支的会话 |
| `Esc` | 退出选择器或搜索模式 |

> **提示：**
> - **尽早命名会话**：在开始不同任务时使用 `/rename` — 以后找 "payment-integration" 比找 "explain this function" 容易得多
> - 使用 `--continue` 快速访问最近的对话
> - 当您知道需要哪个会话时使用 `--resume session-name`
> - 当您需要浏览和选择时使用 `--resume`（不带名称）
> - 对于脚本，使用 `neovate --continue --print "prompt"` 以非交互模式恢复
> - 在选择器中按 `P` 在恢复之前预览会话

---

## 创建自定义斜杠命令

Neovate Code 支持自定义斜杠命令，您可以创建这些命令来快速执行特定的提示或任务。

有关更多详情，请参阅[斜杠命令](/docs/slash-commands)参考页面。

### 创建项目特定命令

假设您想为项目创建可重用的斜杠命令，供所有团队成员使用。

1. 在项目中创建 commands 目录

```bash
mkdir -p .neovate/commands
```

2. 为每个命令创建一个 Markdown 文件

```bash
echo "分析这段代码的性能并建议三个具体的优化：" > .neovate/commands/optimize.md
```

3. 在 Neovate Code 中使用您的自定义命令

```
> /optimize
```

> **提示：**
> - 命令名称来自文件名（例如，`optimize.md` 变成 `/optimize`）
> - 您可以在子目录中组织命令（例如，`.neovate/commands/frontend/component.md` 创建 `/component`，描述中显示 "(project:frontend)"）
> - 项目命令对克隆仓库的所有人可用
> - Markdown 文件内容成为调用命令时发送给 Neovate 的提示

### 使用 $ARGUMENTS 添加命令参数

假设您想创建可以接受用户额外输入的灵活斜杠命令。

1. 创建带有 $ARGUMENTS 占位符的命令文件

```bash
echo '查找并修复问题 #$ARGUMENTS。按照以下步骤：
1. 理解工单中描述的问题
2. 在我们的代码库中定位相关代码
3. 实施解决根本原因的方案
4. 添加适当的测试
5. 准备简洁的 PR 描述' > .neovate/commands/fix-issue.md
```

2. 使用带有问题编号的命令

```
> /fix-issue 123
```

这会将 $ARGUMENTS 替换为提示中的 "123"。

> **提示：**
> - $ARGUMENTS 占位符被命令后面的任何文本替换
> - 您可以在命令模板的任何位置放置 $ARGUMENTS
> - 其他有用的应用：为特定函数生成测试用例、为组件创建文档、审查特定文件中的代码或将内容翻译成指定语言

### 创建个人斜杠命令

假设您想创建适用于所有项目的个人斜杠命令。

1. 在主目录中创建 commands 目录

```bash
mkdir -p ~/.neovate/commands
```

2. 为每个命令创建一个 Markdown 文件

```bash
echo "审查这段代码的安全漏洞，重点关注：" > ~/.neovate/commands/security-review.md
```

3. 使用您的个人自定义命令

```
> /security-review
```

> **提示：**
> - 个人命令在使用 `/help` 列出时在描述中显示 "(user)"
> - 个人命令仅对您可用，不与团队共享
> - 个人命令适用于您的所有项目
> - 您可以使用这些命令在不同代码库中保持一致的工作流程

---

## 下一步

- [CLI 参考](/docs/cli) - 所有命令和选项
- [设置](/docs/settings) - 为您的工作流程自定义 Neovate
- [斜杠命令](/docs/slash-commands) - 创建可重用的提示模板
- [子代理](/docs/subagents) - 生成子代理执行并行任务
